// SPDX-License-Identifier: GPL-3.0
// Copyright (C) {{YEAR}} PaxLabs Inc. GNU General Public License v3.0
// Generated: {{TIMESTAMP}}

pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/AccessControl.sol";

/**
 * @title {{CONTRACT_NAME}}
 * @dev Price oracle with access control and staleness checks
 * @custom:security-contact security@paxeer.network
 */
contract {{CONTRACT_NAME}} is AccessControl {
    bytes32 public constant UPDATER_ROLE = keccak256("UPDATER_ROLE");

    struct PriceData {
        uint256 price;
        uint256 timestamp;
        uint8 decimals;
    }

    mapping(address => PriceData) private _prices;
    
    uint256 public maxStaleness = 1 hours;
    uint8 public immutable defaultDecimals;

    event PriceUpdated(address indexed asset, uint256 price, uint256 timestamp);
    event MaxStalenessUpdated(uint256 oldValue, uint256 newValue);

    error PriceStale(address asset, uint256 timestamp);
    error PriceNotFound(address asset);
    error InvalidPrice();

    /**
     * @dev Constructor sets admin and default decimals
     */
    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(UPDATER_ROLE, msg.sender);
        defaultDecimals = {{DECIMALS}};
    }

    /**
     * @dev Returns the price of an asset
     * @param asset Address of the asset
     * @return price Current price
     * @return decimals Price decimals
     */
    function getPrice(address asset) external view returns (uint256 price, uint8 decimals) {
        PriceData memory data = _prices[asset];
        
        if (data.timestamp == 0) {
            revert PriceNotFound(asset);
        }
        
        if (block.timestamp - data.timestamp > maxStaleness) {
            revert PriceStale(asset, data.timestamp);
        }
        
        return (data.price, data.decimals);
    }

    /**
     * @dev Returns the price of an asset without staleness check
     * @param asset Address of the asset
     */
    function getPriceUnsafe(address asset) external view returns (uint256 price, uint8 decimals, uint256 timestamp) {
        PriceData memory data = _prices[asset];
        return (data.price, data.decimals, data.timestamp);
    }

    /**
     * @dev Updates the price of an asset. Only callable by updaters.
     * @param asset Address of the asset
     * @param price New price
     */
    function setPrice(address asset, uint256 price) external onlyRole(UPDATER_ROLE) {
        _setPrice(asset, price, defaultDecimals);
    }

    /**
     * @dev Updates the price of an asset with custom decimals
     * @param asset Address of the asset
     * @param price New price
     * @param decimals Price decimals
     */
    function setPriceWithDecimals(address asset, uint256 price, uint8 decimals) external onlyRole(UPDATER_ROLE) {
        _setPrice(asset, price, decimals);
    }

    /**
     * @dev Batch updates prices
     * @param assets Array of asset addresses
     * @param prices Array of prices
     */
    function setPriceBatch(address[] calldata assets, uint256[] calldata prices) external onlyRole(UPDATER_ROLE) {
        require(assets.length == prices.length, "Length mismatch");
        
        for (uint256 i = 0; i < assets.length; i++) {
            _setPrice(assets[i], prices[i], defaultDecimals);
        }
    }

    /**
     * @dev Updates max staleness period. Only callable by admin.
     * @param newMaxStaleness New max staleness in seconds
     */
    function setMaxStaleness(uint256 newMaxStaleness) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(newMaxStaleness > 0, "Invalid staleness");
        emit MaxStalenessUpdated(maxStaleness, newMaxStaleness);
        maxStaleness = newMaxStaleness;
    }

    /**
     * @dev Internal function to set price
     */
    function _setPrice(address asset, uint256 price, uint8 decimals) internal {
        if (price == 0) {
            revert InvalidPrice();
        }
        
        _prices[asset] = PriceData({
            price: price,
            timestamp: block.timestamp,
            decimals: decimals
        });
        
        emit PriceUpdated(asset, price, block.timestamp);
    }
}
